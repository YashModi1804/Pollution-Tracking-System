<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Meta Tags -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SSTA | ISRO</title>

  <script src="https://unpkg.com/leaflet-polygon-mask"></script>
  <script src="https://unpkg.com/react/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/recharts/umd/Recharts.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  <!-- Tailwind CSS -->
  <link href="https://unpkg.com/tailwindcss@^1.0/dist/tailwind.min.css" rel="stylesheet" />

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

  <!-- Custom Styles -->
  <style>
    /* Ensure the body and html take full height */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    /* Map Containers */
    .map-container {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 0; /* Base layer */
    }

    /* Leaflet Map Styling */
    #map {
      height: 100%;
      width: 100%;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0; /* Leaflet map at base */
    }

    /* Windy Map Styling */
    #windy {
      height: 100%;
      width: 100%;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1; /* Windy overlay above Leaflet */
      pointer-events: none; /* Allow interactions to pass through */
      opacity: 0.6; /* Adjust opacity as needed */
      display: none;
    }

    /* Form Container Styling */
    .form-container {
      position: relative; /* Ensure it maintains its layout */
      z-index: 10; /* Above both maps */
      max-width: 400px;
    }

    /* Legend Styling */
    .legend {
      background: white;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
      font-family: Arial, sans-serif;
      position: absolute;
      bottom: 110px;
      left: 110px;
      z-index: 1000; /* Above both maps */
    }

    .legend h4 {
      margin: 0 0 5px;
      font-size: 16px;
    }

    .legend .gradient {
      width: 100%;
      height: 20px;
      background: linear-gradient(to right, blue, cyan, green, yellow, red);
    }

    .legend .labels {
      display: flex;
      justify-content: space-between;
      margin-top: 5px;
      font-size: 14px;
    }

    /* High-Medium-Low Legend Styling */
    .legend-hml {
      display: flex;
      flex-direction: column;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }

    .legend-color {
      width: 20px;
      height: 20px;
      margin-right: 5px;
    }
    select:disabled {
    background-color: #f9f9f9;
    color: #a0a0a0;
    cursor: not-allowed;
    }
    #chatbot-container {
        position: absolute;  /* Change from fixed to absolute */
        top: 120px;         /* Position below the header */
        left: 20px;         /* Distance from left edge */
        width: 300px;       /* Fixed width instead of percentage */
        height: 400px;      /* Fixed height */
        background-color: white;
        border-radius: 0.5rem;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        z-index: 1000;      /* Ensure it's above the map */
        display: flex;
        flex-direction: column;
    }

    #chat-messages {
        flex-grow: 1;
        overflow-y: auto;
        padding: 1rem;
    }

    .chat-header {
        padding: 0.75rem;
        background-color: #2563eb;
        color: white;
        border-top-left-radius: 0.5rem;
        border-top-right-radius: 0.5rem;
    }

    .chat-input-container {
        padding: 0.75rem;
        border-top: 1px solid #e5e7eb;
        background-color: white;
    }

  </style>
</head>
<body class="text-gray-600 body-font">
  <!-- Header -->
  <header class="text-gray-600 body-font">
    <div class="container mx-auto flex flex-wrap p-5 flex-col md:flex-row items-center">
      <a class="flex title-font font-medium items-center text-gray-900 mb-4 md:mb-0">
        <img src="{{ url_for('static', filename='nrsc-isro.png') }}" alt="ISU" class="w-auto h-20 p-2" />
        <span class="ml-3 text-xl">Smart System for Tracking Air Pollution</span>
      </a>
      <nav class="md:ml-auto flex flex-wrap items-center text-base justify-center">
        <a href="/" class="mr-5 hover:text-gray-900">Home</a>
        <a href="/about" class="mr-5 hover:text-gray-900">About</a>
        <a href="https://github.com/drashutoshspace/SSTA-Smart-System-for-Tracking-Airpollution" target="_blank" class="mr-5 hover:text-gray-900">Github</a>
      </nav>
    </div>
  </header>

  <!-- Main Section -->
  <section class="text-gray-600 body-font relative">
    <!-- Map Containers -->
    <div class="map-container">
      <div id="map"></div> <!-- Leaflet Map -->
      <div id="windy"></div> <!-- Windy Map -->
    </div>

    <!-- Form Container -->
    <div class="container px-5 py-24 mx-auto flex">
      <div class="lg:w-1/4 md:w-1/3 bg-white rounded-lg p-3 flex flex-col md:ml-auto w-full mt-5 md:mt-0 relative z-10 form-container">
        <h2 class="text-gray-900 text-sm mb-2 font-medium title-font">Select City</h2>
        <p class="leading-relaxed mb-3 text-gray-600 text-xs">Select a city or enter the latitude and longitude to view the pollutant concentration over that area.</p>
        
        <div id="boundary-options" style="display: none; margin-top: 10px;">
          <label style="margin-right: 20px; font-size: 0.75rem;">
              <input type="radio" name="boundary-type" id="use-city-boundary1" value="city" checked>
              City
          </label>
          <label style="margin-right: 20px; font-size: 0.75rem;">
              <input type="radio" name="boundary-type" id="use-state-boundary" value="state">
               State
          </label>
      </div>
      
        <!-- City Selection -->
        <div class="relative mb-3">
          <label for="city" class="leading-7 text-xs text-gray-600">City</label>
          <select id="city" name="city" class="w-full bg-white rounded border border-gray-300 focus:border-indigo-500 focus:ring-2 focus:ring-indigo-200 text-xs outline-none text-gray-700 py-1 px-2 leading-6 transition-colors duration-200 ease-in-out">
            <option value="Manual"><b>Enter Manually</b></option>
            <option value="Delhi">Delhi</option>
            <option value="Mumbai">Mumbai</option>
            <option value="Kolkata">Kolkata</option>
            <option value="Chennai">Chennai</option>
            <option value="Bengaluru">Bengaluru</option>
            <option value="Hyderabad" selected>Hyderabad</option>
            <option value="Pune">Pune</option>
            <option value="Ahmedabad">Ahmedabad</option>
            <!-- <option value="Jaipur">Jaipur</option> -->
            <option value="Lucknow">Lucknow</option>
            <option value="Surat">Surat</option>
            <option value="Kanpur">Kanpur</option>
            <option value="Nagpur">Nagpur</option>
            <option value="Indore">Indore</option>
            <option value="Thane">Thane</option>
            <option value="Bhopal">Bhopal</option>
            <option value="Patna">Patna</option>
            <option value="Vadodara">Vadodara</option>
            <!-- <option value="Ludhiana">Ludhiana</option> -->
            <!-- <option value="Agra">Agra</option>             -->
          </select>
        </div>
        <!-- State and UT Selection Block -->
<div id="state-block" style="display: none;">
  <label for="state" class="leading-7 text-xs text-gray-600">State/UT</label>
  <select id="state" name="state" class="w-full bg-white rounded border border-gray-300 focus:border-indigo-500 focus:ring-2 focus:ring-indigo-200 text-xs outline-none text-gray-700 py-1 px-2 leading-6 transition-colors duration-200 ease-in-out">
    <option value="Andhra Pradesh">Andhra Pradesh</option>
    <option value="Arunachal Pradesh">Arunachal Pradesh</option>
    <option value="Assam">Assam</option>
    <option value="Bihar">Bihar</option>
    <option value="Chhattisgarh">Chhattisgarh</option>
    <option value="Goa">Goa</option>
    <option value="Gujarat">Gujarat</option>
    <option value="Haryana">Haryana</option>
    <option value="Himachal Pradesh">Himachal Pradesh</option>
    <option value="Jharkhand">Jharkhand</option>
    <option value="Karnataka">Karnataka</option>
    <option value="Kerala">Kerala</option>
    <option value="Madhya Pradesh">Madhya Pradesh</option>
    <option value="Maharashtra">Maharashtra</option>
    <option value="Manipur">Manipur</option>
    <option value="Meghalaya">Meghalaya</option>
    <option value="Mizoram">Mizoram</option>
    <option value="Nagaland">Nagaland</option>
    <option value="Odisha">Odisha</option>
    <option value="Punjab">Punjab</option>
    <option value="Rajasthan">Rajasthan</option>
    <option value="Sikkim">Sikkim</option>
    <option value="Tamil Nadu">Tamil Nadu</option>
    <option value="Telangana">Telangana</option>
    <option value="Tripura">Tripura</option>
    <option value="Uttar Pradesh">Uttar Pradesh</option>
    <option value="Uttarakhand">Uttarakhand</option>
    <option value="West Bengal">West Bengal</option>
    <option value="Andaman and Nicobar Islands">Andaman and Nicobar Islands</option>
    <option value="Chandigarh">Chandigarh</option>
    <option value="Dadra and Nagar Haveli and Daman and Diu">Dadra and Nagar Haveli and Daman and Diu</option>
    <option value="Delhi">Delhi</option>
    <option value="Jammu and Kashmir">Jammu and Kashmir</option>
    <option value="Ladakh">Ladakh</option>
    <option value="Lakshadweep">Lakshadweep</option>
    <option value="Puducherry">Puducherry</option>
  </select>
</div>

        <div id="city-boundary-container">
          <div class="relative mb-3 mt-3">
            <label for="use_city_boundary" class="leading-7 text-xs text-gray-600">
              <input type="checkbox" id="use-shapefile" name="use_city_boundary" class="mr-2">
             ShapeFile
            </label>
          </div>
        </div>
    
        

        <!-- Manual Latitude and Longitude Inputs -->
        <div id="manual-inputs" style="display: none">
          <div class="relative mb-3">
            <label for="lat" class="leading-7 text-xs text-gray-600">Latitude</label>
            <input type="text" id="lat" name="lat" class="w-full bg-white rounded border border-gray-300 focus:border-indigo-500 focus:ring-2 focus:ring-indigo-200 text-xs outline-none text-gray-700 py-1 px-2 leading-6 transition-colors duration-200 ease-in-out" />
          </div>
          <div class="relative mb-3">
            <label for="lon" class="leading-7 text-xs text-gray-600">Longitude</label>
            <input type="text" id="lon" name="lon" class="w-full bg-white rounded border border-gray-300 focus:border-indigo-500 focus:ring-2 focus:ring-indigo-200 text-xs outline-none text-gray-700 py-1 px-2 leading-6 transition-colors duration-200 ease-in-out" />
          </div>
        </div>

        <!-- Buffer Radius -->
        <div id="buffer-container">
          <div class="relative mb-3">
            <label for="buffer" class="leading-7 text-xs text-gray-600">Buffer Radius (meters)</label>
            <input type="text" id="buffer" name="buffer" class="w-full bg-white rounded border border-gray-300 focus:border-indigo-500 focus:ring-2 focus:ring-indigo-200 text-xs outline-none text-gray-700 py-1 px-2 leading-6 transition-colors duration-200 ease-in-out" value="50000" />
          </div>
        </div>
      
        

        <!-- Start and End Dates -->
        <div class="relative mb-3">
          <label for="start_date" class="leading-7 text-xs text-gray-600">Start Date</label>
          <input type="date" id="start_date" name="start_date" class="w-full bg-white rounded border border-gray-300 focus:border-indigo-500 focus:ring-2 focus:ring-indigo-200 text-xs outline-none text-gray-700 py-1 px-2 leading-6 transition-colors duration-200 ease-in-out" />
        </div>
        <div class="relative mb-3">
          <label for="end_date" class="leading-7 text-xs text-gray-600">End Date</label>
          <input type="date" id="end_date" name="end_date" class="w-full bg-white rounded border border-gray-300 focus:border-indigo-500 focus:ring-2 focus:ring-indigo-200 text-xs outline-none text-gray-700 py-1 px-2 leading-6 transition-colors duration-200 ease-in-out" />
        </div>

        <!-- Pollutant Selection -->
        <div class="relative lg:w-full xl:w-full w-full mt-3">
          <label for="pollutant" class="leading-7 text-xs text-gray-600">Pollutant</label>
          <select id="pollutant" name="pollutant" class="w-full bg-gray-100 bg-opacity-50 rounded border border-gray-300 focus:border-indigo-500 focus:bg-white focus:ring-2 focus:ring-indigo-200 text-xs outline-none text-gray-700 py-1 px-2 leading-6 transition-colors duration-200 ease-in-out">
            <option value="CO">CO</option>
            <option value="NO2">NO2</option>
            <!-- <option value="PM2.5">PM2.5</option> -->
            <option value="PM10">PM10</option>
            <option value="SO2">SO2</option>
            <option value="O3">O3</option>
            <option value="HCHO">HCHO</option>
          </select>
        </div>

        <!-- Show Air Direction Checkbox -->
        <div class="relative mb-3 mt-3">
          <label for="show_air_direction" class="leading-7 text-xs text-gray-600">
            <input type="checkbox" id="show_air_direction" name="show_air_direction" class="mr-2">
            Show Live Wind Flow
          </label>
        </br>
          <label for="show_high_medium_low" class="leading-7 text-xs text-gray-600">
            <input type="checkbox" id="show_high_medium_low" name="show_high_medium_low" class="mr-2">
            Show Concentration Regions
          </label>
        </div>

        <!-- Show Concentration Button with Loading Spinner -->
        <button id="show-concentration-btn" class="inline-flex items-center justify-center text-white bg-indigo-500 border-0 py-2 px-4 focus:outline-none hover:bg-indigo-600 rounded text-sm mt-3">
          <span id="button-text">Show Concentration</span>
          <svg id="loading-spinner" class="animate-spin h-5 w-5 ml-2 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v8H4z"></path>
          </svg>
        </button>
      </div>
    </div>

    <!-- Legend -->
    <div id="legend" class="legend"></div>
    <div id="concentration-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
      <div class="bg-white p-4 rounded-lg shadow-lg w-3/4 max-w-3xl relative">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-lg font-semibold">Concentration Time Series</h3>
          <button id="close-modal" class="text-gray-500 hover:text-gray-700">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
        <!-- Ensure the container is relative -->
        <img src="{{ url_for('static', filename='isro.png') }}" alt="Logo" class="logo absolute top-4 left-4 w-12 h-12">
        <div id="concentration-chart" class="h-96"></div>
      </div>
</div>

    <!-- Add this to your HTML file -->
    <!-- <div id="chatbot-container">
      <div class="chat-header">
          <h3 class="text-lg font-semibold">Air Quality Assistant</h3>
      </div>
      
      <div id="chat-messages" class="space-y-4"></div>
      
      <div class="chat-input-container">
          <div class="flex space-x-2">
              <input type="text" id="user-input" 
                  class="flex-1 border rounded-lg px-4 py-2 focus:outline-none focus:border-blue-500"
                  placeholder="Ask about air quality...">
              <button onclick="sendMessage()" 
                  class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700">
                  Send
              </button>
          </div>
      </div>
  </div> -->

  </section>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.4.0/dist/leaflet.js"></script>

  <!-- Windy API JS -->
  <script src="https://api.windy.com/assets/map-forecast/libBoot.js"></script>

  <!-- Main Script -->
  <script>
    
    document.addEventListener("DOMContentLoaded", function () {
      // Initialize Leaflet Map
      let currentCityBoundaryLayer = null;
      // Retain your existing variable names and structure

// Define map boundaries
var lowleft = L.latLng(0, 60);
var upright = L.latLng(40, 100);
var maxBoundArea = L.latLngBounds(lowleft, upright);

// Initialize the map
var leafletMap = L.map('map', {
    zoomControl: false, // Disable default zoom control to re-position it
    maxZoom: 18,
    minZoom: 5,
   
}).setView([22, 77], 5); 


L.control.zoom({
    position: 'bottomright'
}).addTo(leafletMap);

L.tileLayer.wms('https://bhuvan-vec1.nrsc.gov.in/bhuvan/gwc/service/wms?', {
    layers: 'india3',
    format: 'image/png',
    transparent: true,
    attribution: '&copy; <a href="https://bhuvan.nrsc.gov.in">Bhuvan</a>'
}).addTo(leafletMap);

// Add state boundary layer from Bhuvan
L.tileLayer.wms('https://bhuvan-vec1.nrsc.gov.in/bhuvan/gwc/service/wms?', {
    layers: 'basemap:india_state_bound_lebel_new', // State boundary layer
    format: 'image/png',
    transparent: true,
    attribution: '&copy; <a href="https://bhuvan.nrsc.gov.in">Bhuvan</a>'
}).addTo(leafletMap);

// Add map scale (in km only)
// L.control.scale({
//     imperial: false, // Disable miles (only show km)
//     position: 'bottomleft'
// }).addTo(map);




      let windyAPIInstance = null;
      let currentBuffer = null;
      let stateLayer = null;
      let windyDiv = document.getElementById("windy");
      let currentPollutantLayer = null;
      let cityBoundaryLayer = null;
      const cityBoundaryRadio = document.getElementById('use-city-boundary1');
  const stateBoundaryRadio = document.getElementById('use-state-boundary');
  const cityDropdown = document.getElementById('city');
  const stateDropdown = document.getElementById('state');

  const updateDropdownState = () => {
    if (cityBoundaryRadio.checked) {
      cityDropdown.disabled = false;
      cityDropdown.title = ''; // Clear any tooltip
      stateDropdown.disabled = true;
      stateDropdown.title = 'Disabled: Select "State" option to enable this';
    } else if (stateBoundaryRadio.checked) {
      stateDropdown.disabled = false;
      stateDropdown.title = ''; // Clear any tooltip
      cityDropdown.disabled = true;
      cityDropdown.title = 'Disabled: Select "City" option to enable this';
    }
  };

  // Initialize state on page load
  updateDropdownState();

  // Add event listeners
  cityBoundaryRadio.addEventListener('change', updateDropdownState);
  stateBoundaryRadio.addEventListener('change', updateDropdownState);
      // Load India Boundary GeoJSON
      fetch("{{ url_for('static', filename='India_State_Boundary.geojson') }}")
        .then((response) => response.json())
        .then((geojson) => {
          L.geoJSON(geojson, {
            style: {
              color: "grey",
              weight: 1,
              opacity: 0.8,
            },
          }).addTo(leafletMap);
        })
        .catch((error) => console.error("Error loading India GeoJSON:", error));

      // Set default dates for start_date and end_date inputs
      const endDateInput = document.getElementById("end_date");
      const startDateInput = document.getElementById("start_date");

      const today = new Date();
      const yesterday = new Date(today);
      yesterday.setDate(yesterday.getDate() - 1);

      const oneMonthBeforeYesterday = new Date(yesterday);
      oneMonthBeforeYesterday.setMonth(oneMonthBeforeYesterday.getMonth() - 1);

      // Format dates to YYYY-MM-DD
      const formatDate = (date) => {
        let month = '' + (date.getMonth() + 1);
        let day = '' + date.getDate();
        const year = date.getFullYear();

        if (month.length < 2)
          month = '0' + month;
        if (day.length < 2)
          day = '0' + day;

        return [year, month, day].join('-');
      }

      endDateInput.value = formatDate(yesterday);
      startDateInput.value = formatDate(oneMonthBeforeYesterday);
      document.getElementById("use-shapefile").addEventListener("change", function() {
        const useCityBoundary = this.checked;
        const bufferContainer = document.getElementById("buffer-container");
        document.getElementById("boundary-options").style.display = this.checked ? "block" : "none";
       
        const bufferInput = document.getElementById("buffer");  // The radius input
        const stateContainer = document.getElementById('state-block');
        if (useCityBoundary) {
          stateContainer.style.display = 'block'; // Show the state dropdown
        } else {
          stateContainer.style.display = 'none'; // Hide the state dropdown
        if (stateLayer) {
          leafletMap.removeLayer(stateLayer);
          stateLayer = null;
        }
        }
        

       
  if (useCityBoundary) {
    // Disable the buffer radius input
    bufferInput.disabled = true;
    bufferContainer.style.display = "none";  // Hide the buffer container
    if (currentBuffer) {
          leafletMap.removeLayer(currentBuffer);
        }
  } else {
    // Enable the buffer radius input
    bufferInput.disabled = false;
    bufferContainer.style.display = "block";  // Show the buffer container
    if (cityBoundaryLayer) {
        leafletMap.removeLayer(cityBoundaryLayer);
    }
  }
      });
        // Function to add the city boundary layer (for the selected city)
  // Function to add the city boundary layer (for the selected city)
  function addCityBoundaryLayer() {
  const showConcentrationBtn = document.getElementById("show-concentration-btn");
  const loadingSpinner = document.getElementById("loading-spinner");
  const buttonText = document.getElementById("button-text");

  if(cityBoundaryLayer){
    leafletMap.removeLayer(cityBoundaryLayer);
  }
  if(stateLayer){
    leafletMap.removeLayer(stateLayer);
  }

  const city = document.getElementById("city").value; 
  let cityGeoJSONUrl = ""; 

  if (city) {
    cityGeoJSONUrl = `/static/dissolved_output/dissolved_${city.toUpperCase()}.geojson`; // Construct the path with the "dissolved_" prefix
  }

  // Fetch and add the city boundary layer if the GeoJSON URL is not empty
  if (cityGeoJSONUrl) {
    fetch(cityGeoJSONUrl)
      .then(response => response.json())
      .then(geojson => {
        currentCityBoundaryLayer = L.geoJSON(geojson, {
          style: {
            
    color: "#FF5733",          // No boundary color
    // weight: 0,            // No boundary weight
    // opacity: 0,           // No boundary opacity
    // fillColor: "red",     // Fill color inside the boundary
    fillOpacity: 0.001      // Transparency of the fill
}

        }).addTo(leafletMap);
        cityBoundaryLayer = currentCityBoundaryLayer;  
        leafletMap.fitBounds(cityBoundaryLayer.getBounds());        
        
        // Hide the loading spinner and reset the button state
        loadingSpinner.classList.add("hidden");
        buttonText.textContent = "Show Concentration";
        showConcentrationBtn.disabled = false;
      })
      .catch((error) => {
        console.error("Error loading city boundary GeoJSON:", error);
        
        // Hide the loading spinner and reset the button state on error
        loadingSpinner.classList.add("hidden");
        buttonText.textContent = "Show Concentration";
        showConcentrationBtn.disabled = false;
        
        // Optionally alert the user about the error
        alert("Failed to load city boundary data. Please try again.");
      });
  }
}
function calculateMovingAverage(data, window = 7) {
  const movingAverages = [];
  for (let i = 0; i < data.length; i++) {
    let sum = 0;
    let count = 0;
    // Look back (window-1) days and include current day
    for (let j = Math.max(0, i - (window - 1)); j <= i; j++) {
      sum += data[j].value;
      count++;
    }
    movingAverages.push({
      date: data[i].date,
      value: sum / count
    });
  }
  return movingAverages;
}

//state boundaries

function loadStateBoundary() {
    const stateName = document.getElementById('state').value;
    const loadingSpinner = document.getElementById("loading-spinner");
    const showConcentrationBtn = document.getElementById("show-concentration-btn");
    const buttonText = document.getElementById("button-text"); // Added missing reference

    const geojsonFileName = stateName + ".geojson";
    const geojsonPath = `/static/state/${geojsonFileName}`;

    if (stateLayer) {
        leafletMap.removeLayer(stateLayer);
    }

    fetch(geojsonPath)
        .then(response => response.json())
        .then(data => {
            stateLayer = L.geoJSON(data, {
                style: {
                    color: "#FF5733",
                    
                    fillOpacity: 0.001
                }
            }).addTo(leafletMap);
            
            if (stateLayer && stateLayer.getBounds) { // Add null check
                leafletMap.fitBounds(stateLayer.getBounds());
            }
            
            loadingSpinner.classList.add("hidden");
            buttonText.textContent = "Show Concentration";
            showConcentrationBtn.disabled = false;
        })
        .catch(error => {
            console.error("Error loading state boundary:", error);
            loadingSpinner.classList.add("hidden");
            buttonText.textContent = "Show Concentration";
            showConcentrationBtn.disabled = false;
        });
}

      // Event Listener for "Show Concentration" Button
      document.getElementById("show-concentration-btn").addEventListener("click", function () {
  const showConcentrationBtn = document.getElementById("show-concentration-btn");
  const loadingSpinner = document.getElementById("loading-spinner");
  const buttonText = document.getElementById("button-text");
  const useCityBoundary = document.getElementById("use-city-boundary1").checked;
  const useStateBoundary = document.getElementById("use-state-boundary").checked;
  const boundaryType = document.querySelector('input[name="boundary-type"]:checked').value;


  if (currentBuffer) {
    leafletMap.removeLayer(currentBuffer);
  }
  if(stateLayer)
  leafletMap.removeLayer(stateLayer);
  if(cityBoundaryLayer)
  leafletMap.removeLayer(cityBoundaryLayer);


  // Show the loading spinner and change the button text
  loadingSpinner.classList.remove("hidden");
  // buttonText.textContent = "Loading...";
  showConcentrationBtn.disabled = false;

  const city = document.getElementById("city").value;
  let lat, lon;

  // Set Latitude and Longitude Based on Selected City
  if(boundaryType==="city")
  if (city === "Delhi") {
    lat = 28.6139;
    lon = 77.2090;
  } else if (city === "Mumbai") {
    lat = 19.0760;
    lon = 72.8777;
  } else if (city === "Kolkata") {
    lat = 22.5726;
    lon = 88.3639;
  } else if (city === "Chennai") {
    lat = 13.0827;
    lon = 80.2707;
  } else if (city === "Bengaluru") {
    lat = 12.9716;
    lon = 77.5946;
  } else if (city === "Hyderabad") {
    lat = 17.3850;
    lon = 78.4867;
  } else if (city === "Pune") {
    lat = 18.5204;
    lon = 73.8567;
  } else if (city === "Ahmedabad") {
    lat = 23.0225;
    lon = 72.5714;
  } else if (city === "Jaipur") {
    lat = 26.9124;
    lon = 75.7873;
  } else if (city === "Lucknow") {
    lat = 26.8467;
    lon = 80.9462;
  } else if (city === "Surat") {
    lat = 21.1702;
    lon = 72.8311;
  } else if (city === "Kanpur") {
    lat = 26.4499;
    lon = 80.3319;
  } else if (city === "Nagpur") {
    lat = 21.1458;
    lon = 79.0882;
  } else if (city === "Indore") {
    lat = 22.7196;
    lon = 75.8577;
  } else if (city === "Thane") {
    lat = 19.2183;
    lon = 72.9781;
  } else if (city === "Bhopal") {
    lat = 23.2599;
    lon = 77.4126;
  } else if (city === "Patna") {
    lat = 25.5941;
    lon = 85.1376;
  } else if (city === "Vadodara") {
    lat = 22.3072;
    lon = 73.1812;
  } else if (city === "Ludhiana") {
    lat = 30.9010;
    lon = 75.8573;
  } else if (city === "Agra") {
    lat = 27.1767;
    lon = 78.0081;
  }
  else if (city === "Manual") {
    lat = parseFloat(document.getElementById("lat").value);
    lon = parseFloat(document.getElementById("lon").value);
  }
  const state = document.getElementById("state").value;

  //state lat-lon block
  if(boundaryType==="state")
  if (state === "Andhra Pradesh") {
    lat = 15.9129;
    lon = 79.7400;
} else if (state === "Arunachal Pradesh") {
    lat = 28.2180;
    lon = 94.7278;
} else if (state === "Assam") {
    lat = 26.2006;
    lon = 92.9376;
} else if (state === "Bihar") {
    lat = 25.0961;
    lon = 85.3131;
} else if (state === "Chhattisgarh") {
    lat = 21.2787;
    lon = 81.8661;
} else if (state === "Goa") {
    lat = 15.2993;
    lon = 74.1240;
} else if (state === "Gujarat") {
    lat = 22.2587;
    lon = 71.1924;
} else if (state === "Haryana") {
    lat = 29.0588;
    lon = 76.0856;
} else if (state === "Himachal Pradesh") {
    lat = 31.1048;
    lon = 77.1734;
} else if (state === "Jharkhand") {
    lat = 23.6102;
    lon = 85.2799;
} else if (state === "Karnataka") {
    lat = 15.3173;
    lon = 75.7139;
} else if (state === "Kerala") {
    lat = 10.8505;
    lon = 76.2711;
} else if (state === "Madhya Pradesh") {
    lat = 22.9734;
    lon = 78.6569;
} else if (state === "Maharashtra") {
    lat = 19.7515;
    lon = 75.7139;
} else if (state === "Manipur") {
    lat = 24.6637;
    lon = 93.9063;
} else if (state === "Meghalaya") {
    lat = 25.4670;
    lon = 91.3662;
} else if (state === "Mizoram") {
    lat = 23.1645;
    lon = 92.9376;
} else if (state === "Nagaland") {
    lat = 26.1584;
    lon = 94.5624;
} else if (state === "Odisha") {
    lat = 20.9517;
    lon = 85.0985;
} else if (state === "Punjab") {
    lat = 31.1471;
    lon = 75.3412;
} else if (state === "Rajasthan") {
    lat = 27.0238;
    lon = 74.2179;
} else if (state === "Sikkim") {
    lat = 27.5330;
    lon = 88.5122;
} else if (state === "Tamil Nadu") {
    lat = 11.1271;
    lon = 78.6569;
} else if (state === "Telangana") {
    lat = 18.1124;
    lon = 79.0193;
} else if (state === "Tripura") {
    lat = 23.9408;
    lon = 91.9882;
} else if (state === "Uttar Pradesh") {
    lat = 26.8467;
    lon = 80.9462;
} else if (state === "Uttarakhand") {
    lat = 30.0668;
    lon = 79.0193;
} else if (state === "West Bengal") {
    lat = 22.9868;
    lon = 87.8550;
} else if (state === "Andaman and Nicobar Islands") {
    lat = 11.6670;
    lon = 92.7359;
} else if (state === "Chandigarh") {
    lat = 30.7333;
    lon = 76.7794;
} else if (state === "Dadra and Nagar Haveli and Daman and Diu") {
    lat = 20.3974;
    lon = 72.8328;
} else if (state === "Delhi") {
    lat = 28.7041;
    lon = 77.1025;
} else if (state === "Jammu and Kashmir") {
    lat = 33.7782;
    lon = 76.5762;
} else if (state === "Ladakh") {
    lat = 34.1526;
    lon = 77.5771;
} else if (state === "Lakshadweep") {
    lat = 10.5667;
    lon = 72.6413;
} else if (state === "Puducherry") {
    lat = 11.9416;
    lon = 79.8083;
} else {
    alert("Please select a valid State/UT.");
    return;
}

  // Validate Latitude and Longitude
  if (isNaN(lat) || isNaN(lon)) {
    alert("Please enter valid latitude and longitude.");
    // Hide the loading spinner and reset the button text
    loadingSpinner.classList.add("hidden");
    buttonText.textContent = "Show Concentration";
    showConcentrationBtn.disabled = false;
    return;
  }

  const bufferRadius = parseInt(document.getElementById("buffer").value, 10);
  const startDate = document.getElementById("start_date").value;
  const endDate = document.getElementById("end_date").value;
  const pollutant = document.getElementById("pollutant").value;
  const showAirDirection = document.getElementById("show_air_direction").checked;
  // Capture the state of the new checkbox
  const shape = document.getElementById("use-shapefile").checked;
  const showHighMediumLow = document.getElementById("show_high_medium_low").checked;


  // Remove Existing Buffer if Any
  if (currentBuffer) {
    leafletMap.removeLayer(currentBuffer);
  }
  // If using City Boundary, ensure the buffer circle is not added
  if (shape && useCityBoundary) {

    addCityBoundaryLayer(); // Add city boundary layer
    leafletMap.fitBounds(cityBoundaryLayer.getBounds());
          
    const adjustedCenter = [lat, lon + 0.1]; 
    leafletMap.setView(adjustedCenter, leafletMap.getZoom());

  }
  else if(useStateBoundary) {
    loadStateBoundary(); // Add state boundary layer
    leafletMap.fitBounds(stateLayer.getBounds());

    const adjustedCenter = [lat, lon + 0.2]; // Adjusted center for state boundary view
    leafletMap.setView(adjustedCenter, leafletMap.getZoom());
  }
  else {
    // If not using city boundary, add a circular buffer
    if(currentBuffer)
    leafletMap.removeLayer(currentBuffer);

    currentBuffer = L.circle([lat, lon], {
      radius: bufferRadius,
      color: "red",
      fillColor: "#f03",
      fillOpacity: 0,
    }).addTo(leafletMap);

    // Adjust map view to fit the buffer
    leafletMap.fitBounds(currentBuffer.getBounds());
    const adjustedCenter = [lat, lon + 0.1]; // Adjust center if necessary
    leafletMap.setView(adjustedCenter, leafletMap.getZoom());
  }
  // Add New Buffer Circle only if the checkbox is NOT checked (buffer mode)
  if (!shape) {
    if(currentBuffer)
    leafletMap.removeLayer(currentBuffer);

    currentBuffer = L.circle([lat, lon], {
      radius: bufferRadius,
      color: "red",
      fillColor: "#f03",
      fillOpacity: 0,
    }).addTo(leafletMap);

    // Adjust Map View to Fit Buffer Bounds
    leafletMap.fitBounds(currentBuffer.getBounds());
    const adjustedCenter = [lat, lon + 0.1]; 
    leafletMap.setView(adjustedCenter, leafletMap.getZoom());
  }
  loadingSpinner.classList.add("hidden");
  buttonText.textContent = "Show Concentration";
  showConcentrationBtn.disabled = false;

  // Fetch Pollutant Data from API based on the checkbox
  if(!shape){
    fetch(`/api/get-pollutant?lat=${lat}&lon=${lon}&buffer=${bufferRadius}&start_date=${startDate}&end_date=${endDate}&pollutant=${pollutant}&hml=${showHighMediumLow}`)
    .then((response) => response.json())
    .then((data) => {
      if (data.error) {
        alert(data.error);
        // Hide the loading spinner and reset the button text
        loadingSpinner.classList.add("hidden");
        buttonText.textContent = "Show Concentration";
        showConcentrationBtn.disabled = false;
        return;
      }

      // Create Pollutant Layer for city boundary if checkbox is checked
      if (showHighMediumLow) {
        // Remove Existing Pollutant Layer
        if (currentPollutantLayer) {
          leafletMap.removeLayer(currentPollutantLayer);
        }

        const pollutantLayer = L.tileLayer(data.tile_url, {
          opacity: 0.6,
          minZoom: 1,
          maxZoom: 1000,
          attribution: '&copy; <a href="https://earthengine.google.com/">Google Earth Engine</a>',
        });
        if (currentPollutantLayer) {
        leafletMap.removeLayer(currentPollutantLayer);
      }
        // Add Pollutant Layer to Map
        pollutantLayer.addTo(leafletMap);
        currentPollutantLayer = pollutantLayer;
        

        // Update Legend
        const unit = data.unit || "";
        const minValue = data.min_raw;
        const maxValue = data.max_raw;
        updateLegend(minValue, maxValue, unit, data.legend_labels);
      } else {
        // Handle buffer-based pollutant layer
        const pollutantLayer = L.tileLayer(data.tile_url, {
          opacity: 0.6,
          minZoom: 1,
          maxZoom: 1000,
          attribution: '&copy; <a href="https://earthengine.google.com/">Google Earth Engine</a>',
        });

        // Remove Existing Pollutant Layer
        if (currentPollutantLayer) {
          leafletMap.removeLayer(currentPollutantLayer);
        }

        // Add Event Listener for Tile Layer Load Completion
        pollutantLayer.on('load', function () {
          // Tiles are fully loaded
          loadingSpinner.classList.add("hidden");
          buttonText.textContent = "Show Concentration";
          showConcentrationBtn.disabled = false;
        });

        // Add Pollutant Layer to Map
        pollutantLayer.addTo(leafletMap);
        currentPollutantLayer = pollutantLayer;
        leafletMap.on('click', async function (e) {
  if (currentPollutantLayer && !document.getElementById("use-shapefile").checked) {
    const clickedPoint = e.latlng;
    const pollutant = document.getElementById("pollutant").value;
    const startDate = document.getElementById("start_date").value;
    const endDate = document.getElementById("end_date").value;

    try {
      const response = await fetch(`/api/get-time-series?lat=${clickedPoint.lat}&lon=${clickedPoint.lng}&pollutant=${pollutant}&start_date=${startDate}&end_date=${endDate}`);
      const data = await response.json();

      if (data.error) {
        alert(data.error);
        return;
      }

      renderConcentrationChart(data);
      document.getElementById('concentration-modal').classList.remove('hidden');
    } catch (error) {
      console.error("Error fetching time series data:", error);
      alert("An error occurred while fetching time series data.");
    }
  }
});
function renderConcentrationChart(data) {
  const chartContainer = document.getElementById('concentration-chart');
  const pollutant = document.getElementById("pollutant").value; // Get pollutant name

  // Clear the chart container before rendering the new chart
  chartContainer.innerHTML = '';

  const ctx = document.createElement('canvas');
  chartContainer.appendChild(ctx);

  // Calculate 7-day moving average if we have more than 7 data points
  const datasets = [{
    label: `Concentration (${data.unit})`,
    data: data.series.map(item => item.value),
    borderColor: '#8884d8',
    borderWidth: 1,
    fill: false
  }];

  if (data.series.length > 7) {
    const movingAverages = calculateMovingAverage(data.series);
    datasets.push({
      label: '7-day Moving Average',
      data: movingAverages.map(item => item.value),
      borderColor: '#ff0000',
      borderWidth: 2,
      fill: false,
      borderDash: [5, 5] // Optional: makes the line dashed
    });
  }

  new Chart(ctx, {
    type: 'line',
    data: {
      labels: data.series.map(item => item.date),
      datasets: datasets
    },
    options: {
      responsive: true,
      scales: {
        x: {
          type: 'category',
          title: {
            display: true,
            text: 'Date'
          }
        },
        y: {
          title: {
            display: true,
            text: `Concentration (${data.unit})`
          }
        }
      },
      plugins: {
        legend: {
          display: true,
          position: 'top'
        },
        tooltip: {
          mode: 'index',
          intersect: false
        },
        title: {
          display: true,
          text: `${pollutant} Concentration Over Time`, // Add pollutant name to chart title
          font: {
            size: 16
          }
        },
        subtitle: {
          display: true,
          text: `Unit: ${data.unit}`, // Optional: Add a subtitle if you want more context
          font: {
            size: 12,
            style: 'italic'
          },
          padding: {
            bottom: 10
          }
        }
      }
    }
  });
}

document.getElementById('close-modal').addEventListener('click', function () {
  document.getElementById('concentration-modal').classList.add('hidden');
});




        // Update Legend
        updateLegend(data.min_raw, data.max_raw, data.unit, data.legend_labels);
      }

      // Initialize Windy API if Wind Flow is Selected
      if (showAirDirection) {
        windyDiv.style.display = "block";

        if (!windyAPIInstance) {
          windyInit({
            key: 'DHnqHp6YzeueWA6uhkK3cxT8USF5QsuX', // Replace 'YOUR_API_KEY' with your actual API key
            lat: lat,
            lon: lon,
            zoom: leafletMap.getZoom(),
            container: 'windy',
            overlay: 'wind',
          }, function (windyAPI) {
            console.log('Windy API Initialized');
            windyAPIInstance = windyAPI;

            const { map: windyMap } = windyAPI;

            // Synchronize Windy Map with Leaflet Map
            leafletMap.on('moveend zoomend', () => {
              const center = leafletMap.getCenter();
              const zoom = leafletMap.getZoom();
              windyMap.setView([center.lat, center.lng], zoom);
            });

            // Initial synchronization
            const center = leafletMap.getCenter();
            const zoom = leafletMap.getZoom();
            windyMap.setView([center.lat, center.lng], zoom);
          });
        } else {
          // If Windy is already initialized, just update the view
          const { map: windyMap } = windyAPIInstance;
          const center = leafletMap.getCenter();
          const zoom = leafletMap.getZoom();
          windyMap.setView([center.lat, center.lng], zoom);
        }
      } else {
        windyDiv.style.display = "none";
      }
    })
    .catch((error) => {
      console.error("Error fetching Concentration Data:", error);
      alert("An error occurred while fetching data.");

      // Hide the loading spinner and reset the button text
      loadingSpinner.classList.add("hidden");
      buttonText.textContent = "Show Concentration";
      showConcentrationBtn.disabled = false;
    });
  }
  else{
    if(useCityBoundary){
      fetch(`/api/get-pollutant-city?city=${city}&start_date=${startDate}&end_date=${endDate}&pollutant=${pollutant}&hml=${showHighMediumLow}`)
      .then((response) => response.json())
      .then((data) => {
        if (data.error) {
          alert(data.error);
          // Hide the loading spinner and reset the button text
          loadingSpinner.classList.add("hidden");
          buttonText.textContent = "Show Concentration";
          showConcentrationBtn.disabled = false;
          return;
        }

        // Handle city-based pollutant layer
        const pollutantLayer = L.tileLayer(data.tile_url, {
          opacity: 0.6,
          minZoom: 1,
          maxZoom: 1000,
          attribution: '&copy; <a href="https://earthengine.google.com/">Google Earth Engine</a>',
        });

        // Remove Existing Pollutant Layer
        if (currentPollutantLayer) {
          leafletMap.removeLayer(currentPollutantLayer);
        }

        // Add Pollutant Layer to Map
        pollutantLayer.addTo(leafletMap);
        currentPollutantLayer = pollutantLayer;
        leafletMap.on('click', async function(e) {
  // Only process clicks if we have an active pollutant layer and shapefile mode is active
  if (currentPollutantLayer && document.getElementById("use-shapefile").checked) {
    const clickedPoint = e.latlng;
    
    // Check if click is within the current boundary layer
    let isWithinBoundary = false;
    if (cityBoundaryLayer) {
      isWithinBoundary = leafletMap.layerPointToLatLng(
        leafletMap.latLngToLayerPoint(clickedPoint)
      );
    }
    
    if (isWithinBoundary) {
      const pollutant = document.getElementById("pollutant").value;
      const startDate = document.getElementById("start_date").value;
      const endDate = document.getElementById("end_date").value;
      
      try {
        const response = await fetch(`/api/get-time-series?lat=${clickedPoint.lat}&lon=${clickedPoint.lng}&pollutant=${pollutant}&start_date=${startDate}&end_date=${endDate}`);
        const data = await response.json();
        
        if (data.error) {
          alert(data.error);
          return;
        }
        
        renderConcentrationChart(data);
        document.getElementById('concentration-modal').classList.remove('hidden');
      } catch (error) {
        console.error("Error fetching time series data:", error);
        alert("An error occurred while fetching time series data.");
      }
    }
  }
});
document.getElementById('close-modal').addEventListener('click', function() {
  document.getElementById('concentration-modal').classList.add('hidden');
});

function renderConcentrationChart(data) {
  const chartContainer = document.getElementById('concentration-chart');
  const pollutant = document.getElementById("pollutant").value; // Get pollutant name

  // Clear the chart container before rendering the new chart
  chartContainer.innerHTML = '';

  const ctx = document.createElement('canvas');
  chartContainer.appendChild(ctx);

  // Calculate 7-day moving average if we have more than 7 data points
  const datasets = [{
    label: `Concentration (${data.unit})`,
    data: data.series.map(item => item.value),
    borderColor: '#8884d8',
    borderWidth: 1,
    fill: false
  }];

  if (data.series.length > 7) {
    const movingAverages = calculateMovingAverage(data.series);
    datasets.push({
      label: '7-day Moving Average',
      data: movingAverages.map(item => item.value),
      borderColor: '#ff0000',
      borderWidth: 2,
      fill: false,
      borderDash: [5, 5] // Optional: makes the line dashed
    });
  }

  new Chart(ctx, {
    type: 'line',
    data: {
      labels: data.series.map(item => item.date),
      datasets: datasets
    },
    options: {
      responsive: true,
      scales: {
        x: {
          type: 'category',
          title: {
            display: true,
            text: 'Date'
          }
        },
        y: {
          title: {
            display: true,
            text: `Concentration (${data.unit})`
          }
        }
      },
      plugins: {
        legend: {
          display: true,
          position: 'top'
        },
        tooltip: {
          mode: 'index',
          intersect: false
        },
        title: {
          display: true,
          text: `${pollutant} Concentration Over Time`, // Add pollutant name to chart title
          font: {
            size: 16
          }
        },
        subtitle: {
          display: true,
          text: `Unit: ${data.unit}`, // Optional: Add a subtitle if you want more context
          font: {
            size: 12,
            style: 'italic'
          },
          padding: {
            bottom: 10
          }
        }
      }
    }
  });
}

// document.getElementById('close-modal').addEventListener('click', function () {
//   document.getElementById('concentration-modal').classList.add('hidden');
// });

        

        // Update Legend
        updateLegend(
    parseFloat(data.min_raw.toFixed(2)), // Rounds min_raw to 2 decimal places
    parseFloat(data.max_raw.toFixed(2)), // Rounds max_raw to 2 decimal places
    data.unit,
    data.legend_labels
);

      });
    }
    else{
      loadStateBoundary();
      fetch(`/api/get-pollutant-state?state=${state}&start_date=${startDate}&end_date=${endDate}&pollutant=${pollutant}&hml=${showHighMediumLow}`)
      .then((response) => response.json())
      .then((data) => {
        if (data.error) {
          alert(data.error);
          // Hide the loading spinner and reset the button text
          loadingSpinner.classList.add("hidden");
          buttonText.textContent = "Show Concentration";
          showConcentrationBtn.disabled = false;
          return;
        }

        // Handle state-based pollutant layer
        const pollutantLayer = L.tileLayer(data.tile_url, {
          opacity: 0.6,
          minZoom: 1,
          maxZoom: 1000,
          attribution: '&copy; <a href="https://earthengine.google.com/">Google Earth Engine</a>',
        });

        // Remove Existing Pollutant Layer
        if (currentPollutantLayer) {
          leafletMap.removeLayer(currentPollutantLayer);
        }

        // Add Pollutant Layer to Map
        pollutantLayer.addTo(leafletMap);
        currentPollutantLayer = pollutantLayer;
        leafletMap.on('click', async function (e) {
  if (currentPollutantLayer && document.getElementById("use-state-boundary").checked) {
    const clickedPoint = e.latlng;
    const stateBoundaryLayer = document.getElementById("use-state-boundary");
    let isWithinBoundary = false;

    if (stateBoundaryLayer) {
      isWithinBoundary = leafletMap.layerPointToLatLng(
        leafletMap.latLngToLayerPoint(clickedPoint)
      );
    }

    if (isWithinBoundary) {
      const pollutant = document.getElementById("pollutant").value;
      const startDate = document.getElementById("start_date").value;
      const endDate = document.getElementById("end_date").value;

      try {
        const response = await fetch(`/api/get-time-series?lat=${clickedPoint.lat}&lon=${clickedPoint.lng}&pollutant=${pollutant}&start_date=${startDate}&end_date=${endDate}`);
        const data = await response.json();

        if (data.error) {
          alert(data.error);
          return;
        }

        renderConcentrationChart(data);
        document.getElementById('concentration-modal').classList.remove('hidden');
      } catch (error) {
        console.error("Error fetching time series data:", error);
        alert("An error occurred while fetching time series data.");
      }
    }
  }
});
function renderConcentrationChart(data) {
  const chartContainer = document.getElementById('concentration-chart');
  const pollutant = document.getElementById("pollutant").value; // Get pollutant name

  // Clear the chart container before rendering the new chart
  chartContainer.innerHTML = '';

  const ctx = document.createElement('canvas');
  chartContainer.appendChild(ctx);

  // Calculate 7-day moving average if we have more than 7 data points
  const datasets = [{
    label: `Concentration (${data.unit})`,
    data: data.series.map(item => item.value),
    borderColor: '#8884d8',
    borderWidth: 1,
    fill: false
  }];

  if (data.series.length > 7) {
    const movingAverages = calculateMovingAverage(data.series);
    datasets.push({
      label: '7-day Moving Average',
      data: movingAverages.map(item => item.value),
      borderColor: '#ff0000',
      borderWidth: 2,
      fill: false,
      borderDash: [5, 5] // Optional: makes the line dashed
    });
  }

  new Chart(ctx, {
    type: 'line',
    data: {
      labels: data.series.map(item => item.date),
      datasets: datasets
    },
    options: {
      responsive: true,
      scales: {
        x: {
          type: 'category',
          title: {
            display: true,
            text: 'Date'
          }
        },
        y: {
          title: {
            display: true,
            text: `Concentration (${data.unit})`
          }
        }
      },
      plugins: {
        legend: {
          display: true,
          position: 'top'
        },
        tooltip: {
          mode: 'index',
          intersect: false
        },
        title: {
          display: true,
          text: `${pollutant} Concentration Over Time`, // Add pollutant name to chart title
          font: {
            size: 16
          }
        },
        subtitle: {
          display: true,
          text: `Unit: ${data.unit}`, // Optional: Add a subtitle if you want more context
          font: {
            size: 12,
            style: 'italic'
          },
          padding: {
            bottom: 10
          }
        }
      }
    }
  });
}

document.getElementById('close-modal').addEventListener('click', function () {
  document.getElementById('concentration-modal').classList.add('hidden');
});




        // Update Legend
        updateLegend(data.min_raw, data.max_raw, data.unit, data.legend_labels);
      });
  }
    }
  }
  
  
);

// Function to Update Legend
function updateLegend(minValue, maxValue, unit, legendLabels) {
  const legend = document.getElementById("legend");
  const pollutant = document.getElementById("pollutant").value;

  if (legendLabels) {
    // Show High-Medium-Low legend
    legend.innerHTML = `
      <h4>Concentration of ${pollutant}</h4>
      <div class="legend-hml">
        <div class="legend-item">
          <span class="legend-color" style="background-color: blue;"></span>
          <span class="legend-label">Low [<30%]</span>
        </div>
        <div class="legend-item">
          <span class="legend-color" style="background-color: yellow;"></span>
          <span class="legend-label">Medium [30-60%]</span>
        </div>
        <div class="legend-item">
          <span class="legend-color" style="background-color: red;"></span>
          <span class="legend-label">High [>60%]</span>
        </div>
      </div>
    `;
  } else {
    // Show range-based legend with gradient
    legend.innerHTML = `
      <h4>Concentration of ${pollutant}</h4>
      <div class="gradient"></div>
      <div class="labels">
        <span>${minValue}${unit}</span>
        <span>${maxValue}${unit}</span>
      </div>
    `;
  }
}


      // Event Listener for City Selection Change
      document.getElementById("city").addEventListener("change", function () {
        if (this.value === "Manual") {
          document.getElementById("manual-inputs").style.display = "block";
        } else {
          document.getElementById("manual-inputs").style.display = "none";
        }
      });
    });
    // Add this to your JavaScript file
function appendMessage(message, isUser = false) {
    const chatMessages = document.getElementById('chat-messages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `flex ${isUser ? 'justify-end' : 'justify-start'}`;
    
    const messageBubble = document.createElement('div');
    messageBubble.className = `max-w-xs p-3 rounded-lg ${isUser ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-800'}`;
    messageBubble.textContent = message;
    
    messageDiv.appendChild(messageBubble);
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

async function sendMessage() {
    const input = document.getElementById('user-input');
    const message = input.value.trim();
    
    if (!message) return;
    
    // Display user message
    appendMessage(message, true);
    input.value = '';
    
    try {
        const response = await fetch('/api/chat', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ message })
        });
        
        const data = await response.json();
        
        if (data.error) {
            appendMessage('Sorry, I encountered an error: ' + data.error);
        } else {
            appendMessage(data.response);
        }
    } catch (error) {
        appendMessage('Sorry, I encountered an error while processing your request.');
    }
}

// Handle Enter key
document.getElementById('user-input').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        sendMessage();
    }
});
  </script>
</body>
</html>